{
  "name": "Jet Reclustering",
  "tagline": "Recluster Jets in a Single Bound!",
  "body": "# Jet Reclustering\r\n\r\n*This is currently in AnalysisBase releases 2.4.17+.*\r\n\r\nThis tool allows you to recluster small-R xAOD jets into large-R xAOD jets. It provides configurable filtering of the small-R jets, reclustering using standard or variable-R algorithms, configurable trimming of the large-R jets, and jet moment & jet substructure moment calculations.\r\n\r\nIf you would like to get involved, see the twiki for [the JetMET working group for jet reclustering](https://twiki.cern.ch/twiki/bin/view/AtlasProtected/JetReclustering). The [pre-recommendations](https://twiki.cern.ch/twiki/bin/viewauth/AtlasProtected/PreRec) twiki contains the guidelines for your analyses.\r\n\r\n<!-- START doctoc generated TOC please keep comment here to allow auto update -->\r\n<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->\r\n**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*\r\n\r\n- [Installing](#installing)\r\n- [Configurations for](#configurations-for)\r\n  - [`JetReclusteringTool` tool](#jetreclusteringtool-tool)\r\n  - [`JetReclusteringAlgo` algorithm](#jetreclusteringalgo-algorithm)\r\n  - [`AthJetReclusteringAlgo` Athena algorithm](#athjetreclusteringalgo-athena-algorithm)\r\n- [Using Jet Reclustering](#using-jet-reclustering)\r\n  - [Input Jet Filtering](#input-jet-filtering)\r\n  - [Output Reclustered Jet Trimming](#output-reclustered-jet-trimming)\r\n  - [Variable-R Jet Finding](#variable-r-jet-finding)\r\n  - [Area Calculations](#area-calculations)\r\n  - [Incorporating in existing code](#incorporating-in-existing-code)\r\n    - [RootCore](#rootcore)\r\n    - [Athena](#athena)\r\n  - [Incorporating in algorithm chain](#incorporating-in-algorithm-chain)\r\n    - [RootCore](#rootcore-1)\r\n    - [Athena](#athena-1)\r\n- [Studies and Example Usage](#studies-and-example-usage)\r\n  - [Accessing the subjets from constituents](#accessing-the-subjets-from-constituents)\r\n  - [Accessing various jet moments](#accessing-various-jet-moments)\r\n- [Authors](#authors)\r\n\r\n<!-- END doctoc generated TOC please keep comment here to allow auto update -->\r\n\r\n## Installing\r\n\r\nThis works in AB 2.3.X and 2.4.Y on ROOT6 releases. As long as [JetRec](http://acode-browser.usatlas.bnl.gov/lxr/source/atlas/Reconstruction/Jet/JetRec/JetRec/) works, this will be ok.\r\n\r\n```bash\r\nrcSetup Base,2.4.Y # or 2.3.X\r\ngit clone https://github.com/kratsg/JetReclustering.git\r\nrc find_packages\r\nrc compile\r\n```\r\n\r\n*Warning*: use `X >= 45` since I am using `ANA_CHECK` which only works with `EventLoop-00-01-35` or better. Use `Y >= 17` as it is part of the atlas software releases.\r\n\r\n## Configurations for\r\n\r\n### `JetReclusteringTool` tool\r\n\r\n Property           | Type                      | Default                   | Description\r\n:-------------------|:-------------------------:|--------------------------:|:-------------------------------------------------------------------------------------\r\nInputJetContainer   | string                    |                           | name of the input jet container for reclustering\r\nOutputJetContainer  | string                    |                           | name of the output jet container holding reclustered jets\r\nInputJetPtMin       | float                     | 25.0                      | filter input jets by requiring a minimum pt cut [GeV]\r\nReclusterAlgorithm  | string                    | AntiKt                    | name of algorithm for clustering large-R jets {AntiKt, Kt, CamKt}\r\nReclusterRadius     | float                     | 1.0                       | radius of large-R reclustered jets or maximum radius of variable-R jet finding\r\nRCJetPtMin          | float                     | 50.0                      | filter reclustered jets by requiring a minimum pt cut [GeV]\r\nRCJetPtFrac         | float                     | 0.05                      | trim the reclustered jets with a PtFrac on its constituents (eg: small-R input jets)\r\nRCJetSubjetRadius   | float                     | 0.0                       | radius parameter for kt-clustering to form subjets (R=0.0 should not do any clustering)\r\nVariableRMinRadius  | float                     | -1.0                      | minimum radius for variable-R jet finding\r\nVariableRMassScale  | float                     | -1.0                      | mass scale [GeV] for variable-R jet finding\r\nDoArea              | bool                      | false                     | turn on ghost area calculations (set ghost area scale to 0.01)\r\nAreaAttributes      | string                    | ActiveArea ActiveArea4vec | space-delimited list of attributes to transfer over from fastjet\r\n\r\n### `JetReclusteringAlgo` algorithm\r\n\r\nAs well as the provided above configurations for the `JetReclusteringTool`, we also provide a `m_debug` configuration for extra verbose output and an `m_outputXAODName` to create an output xAOD containing the reclustered jets (note: experimental)\r\n\r\nVariable            | Type      | Default                   | Description\r\n:-------------------|:---------:|--------------------------:|:-------------------------------------------------------------------------------------\r\nm_inputJetContainer | string    |                           | see above\r\nm_outputJetContainer| string    |                           | see above\r\nm_ptMin_input       | float     | 25.0                      | see above\r\nm_rc_alg            | string    | AntiKt                    | see above\r\nm_radius            | float     | 1.0                       | see above\r\nm_ptMin_rc          | float     | 50.0                      | see above\r\nm_ptFrac            | float     | 0.05                      | see above\r\nm_subjet_radius     | float     | 0.0                       | see above\r\nm_varR_minR         | float     | -1.0                      | see above\r\nm_varR_mass         | float     | -1.0                      | see above\r\nm_doArea            | bool      | false                     | see above\r\nm_areaAttributes    | string    | ActiveArea ActiveArea4vec | see above\r\nm_outputXAODName    | string    |                           | if defined, put the reclustered jets in an output xAOD file of the given name\r\nm_debug             | bool      | false                     | enable verbose debugging information, such as printing the tool configurations\r\n\r\n### `AthJetReclusteringAlgo` Athena algorithm\r\n\r\n Property           | Type                      | Default                   | Description\r\n:-------------------|:-------------------------:|--------------------------:|:-------------------------------------------------------------------------------------\r\nJetReclusteringTool          | ToolHandle                |                           | The JetReclusteringTool to use. All configurables should be set on this.\r\n\r\n## Using Jet Reclustering\r\n\r\n### Input Jet Filtering\r\n\r\nThe input jets can be filtered using the `InputJetPtMin` or `m_ptMin_input` options. If these are set to 0 (or less), this will turn the jet filtering tool off (essentially skipping the step).\r\n\r\n### Output Reclustered Jet Trimming\r\n\r\nThe output jets can be trimmed using the `RCJetPtFrac` or `m_ptFrac` options. If these are set to 0 (or less), this will turn the reclustered jet trimming tool off (essentially skipping the step). Note that by default, we will not kt-cluster the subjets as `RCJetSubjetRadius` / `m_subjet_radius` are set to 0.0 by default, however one can set them to a non-zero radius value if you want to form subjets (if you somehow passed in `xAOD::Jet` objects that represent clusters rather than small-R jets).\r\n\r\n### Variable-R Jet Finding\r\n\r\nVariable-R jet finding is performed if `VariableRMinRadius >= 0` and `VariableRMassScale >= 0`. For more information on these variables, see the [Jets with Variable R](http://arxiv.org/pdf/0903.0392v1.pdf) paper. If you choose variable-R jet finding, the maximum jet radius will be specified by `ReclusterRadius`. The relevant properties are listed in the following table\r\n\r\n Property           | Type                      | Default                   | Description\r\n:-------------------|:-------------------------:|--------------------------:|:-------------------------------------------------------------------------------------\r\nReclusterRadius     | float                     | 1.0                       | maximum radius of variable-R jet finding\r\nVariableRMinRadius  | float                     | -1.0                      | minimum radius for variable-R jet finding\r\nVariableRMassScale  | float                     | -1.0                      | mass scale [GeV] for variable-R jet finding\r\n\r\nWhen a new jet is formed using variable-R jet finding, it will have some extra attributes as mentioned on the [Run 2 - Jet Moments](https://twiki.cern.ch/twiki/bin/viewauth/AtlasProtected/Run2JetMoments) twiki. We will also decorate with an `EffectiveR` attribute as well which reflects the effective radius of the reclustered jet using its untrimmed transverse momentum. To summarize the translations\r\n\r\n Property           | Type                      | Jet Attribute\r\n:-------------------|:-------------------------:|--------------------\r\nReclusterRadius     | float                     | SizeParameter\r\nVariableRMinRadius  | float                     | VariableRMinRadius\r\nVariableRMassScale  | float                     | VariableRMassScale\r\n                    | float                     | EffectiveR\r\n\r\n### Area Calculations\r\n\r\nAreas can be calculated and added to the jets. Fastjet does the area calculation and these values can be transferred over using the `JetFromPseudojet` tool. To make this happen, simply enable `m_doArea` (`DoArea`) which will set the ghost area size to `0.01` which is a reasonable default for most use cases. The attributes that get transferred over are defined in `m_areaAttributes` (`AreaAttributes`). As of the time of writing this section of the README, there were only two allowed values which would get decorated:\r\n\r\n- `ActiveArea` (most people use this one)\r\n- `ActiveArea4vec`\r\n\r\n### Incorporating in existing code\r\n\r\n#### RootCore\r\n\r\nIf you wish to incorporate `JetReclustering` directly into your code, add this package as a dependency in `cmt/Makefile.RootCore` and then a header\r\n\r\n```c++\r\n#include <AsgTools/AnaToolHandle.h>\r\n#include <JetInterface/IJetExecuteTool.h>\r\n\r\nclass MyAlgo : public EL::Algorithm {\r\n  // ...\r\n\r\n  asg::AnaToolHandle<IJetExecuteTool> m_jetReclusteringTool; //!\r\n}\r\n```\r\n\r\nto get started. In the source, you need to add the tool header\r\n\r\n```c++\r\n#include <JetReclustering/JetReclusteringTool.h>\r\n```\r\n\r\nthen make sure the AsgTool tool store sets up the tool correctly in the constructor\r\n\r\n```c++\r\nMyAlgo :: MyAlgo () :\r\n  m_jetReclusteringTool(\"JetReclusteringTool/ANameForTheTool\")\r\n  {}\r\n```\r\n\r\nAt this point, you can set up your standard tool in the `initialize()` portion of your algorithm as a tool handle\r\n\r\n```c++\r\nANA_CHECK_SET_TYPE (EL::StatusCode);\r\nANA_CHECK(ASG_MAKE_ANA_TOOL(m_jetReclusteringTool, JetReclusteringTool));\r\nANA_CHECK(m_jetReclusteringTool.setProperty(\"InputJetContainer\",  m_inputJetContainer));\r\nANA_CHECK(m_jetReclusteringTool.setProperty(\"OutputJetContainer\", m_outputJetContainer));\r\nANA_CHECK(m_jetReclusteringTool.setProperty(\"ReclusterRadius\",    m_radius));\r\nANA_CHECK(m_jetReclusteringTool.setProperty(\"ReclusterAlgorithm\", m_rc_alg));\r\nANA_CHECK(m_jetReclusteringTool.setProperty(\"VariableRMinRadius\", m_varR_minR));\r\nANA_CHECK(m_jetReclusteringTool.setProperty(\"VariableRMassScale\", m_varR_mass));\r\nANA_CHECK(m_jetReclusteringTool.setProperty(\"InputJetPtMin\",      m_ptMin_input));\r\nANA_CHECK(m_jetReclusteringTool.setProperty(\"RCJetPtMin\",         m_ptMin_rc));\r\nANA_CHECK(m_jetReclusteringTool.setProperty(\"RCJetPtFrac\",        m_ptFrac));\r\nANA_CHECK(m_jetReclusteringTool.setProperty(\"RCJetSubjetRadius\",  m_subjet_radius));\r\nANA_CHECK(m_jetReclusteringTool.setProperty(\"DoArea\",             m_doArea));\r\nANA_CHECK(m_jetReclusteringTool.setProperty(\"AreaAttributes\",     m_areaAttributes));\r\nANA_CHECK(m_jetReclusteringTool.retrieve());\r\n```\r\n\r\nand then simply call `m_jetReclusteringTool->execute()` in the `execute()` portion of your algorithm to fill the TStore with the appropriate container(s). Note that you use a pointer on the second portion when calling `execute()` to access the underlying pointer to the tool itself. The functions `setProperty()` and `initialize()` have a return type `StatusCode` which needs to be checked.\r\n\r\n#### Athena\r\n\r\nThe methods for incorporating the code into an Athena algorithm are very similar to the method for RootCore.\r\nThe package must be included with a 'use' statement in `cmt/requirements`. Then in your header:\r\n```c++\r\n#include <AsgTools/ToolHandle.h> // Can use AnaToolHandle instead if you want\r\n#include <JetInterface/IJetExecuteTool.h>\r\n\r\nclass MyAlgo : public ::AthAnalysisAlgorithm { // Or any of the other Athena algorithm types\r\n  // ...\r\n\r\n  ToolHandle<IJetExecuteTool> m_jetReclusteringTool;\r\n};\r\n```\r\n\r\nAs with other Athena algorithms it's recommended to configure the tool in your job options and then pass it into your algorithm as a property. To do this, in the constructor you need to initialize the handle and declare it as a property\r\n\r\n```c++\r\n\r\nMyAlgo::MyAlgo( const std::string& name, ISvcLocator* pSvcLocator )\r\n: AthAnalysisAlgorithm( name, pSvcLocator ), // Or other base class\r\n  m_jetReclusteringTool(\"\") // Can also initialize with a default type/name if you wish\r\n{\r\n  // Other properties...\r\n  declareProperty( \"JetReclusteringTool\", m_jetReclusteringTool );\r\n}\r\n```\r\n\r\nThen in the `initialize()` member function of your algorithm `retrieve` the tool\r\n\r\n```c++\r\n  ATH_CHECK( m_jetReclusteringTool.retrieve() );\r\n```\r\n\r\nTo use it in your algorithm you can call (in your `execute()` function). Make sure you do this **before** anyone tries to use the output...\r\n```c++\r\n  int retCode = m_jetReclusteringTool->execute();\r\n  if (retCode != 0) {\r\n    ATH_MSG_ERROR( \"JetReclusteringTool failed in execution with code: \" << retCode );\r\n    return StatusCode::FAILURE;\r\n  }\r\n```\r\n\r\nThen you need to create and pass in your tool in your joboptions (see the section below for more instructions, replace `AthJetReclusteringAlgo` with `MyAlgo` or whatever you called your algorithm).\r\nIt is also possible to set the properties and initialize your tool in the cxx code but this isn't really recommended. If you want to do this either use AnaToolHandle and setProperty (analogously to in RootCore) or use ToolHandle and [AthAnalysisHelper](http://acode-browser2.usatlas.bnl.gov/lxr-AthAna/source/atlas/Control/AthAnalysisBaseComps/AthAnalysisBaseComps/AthAnalysisHelper.h#0053).\r\n\r\n### Incorporating in algorithm chain\r\n\r\n#### RootCore\r\n\r\nThis is the least destructive option since it requires **no change** to your existing code. All you need to do is create a new `JetReclusteringAlgo` algorithm and add it to the job before other algorithms downstream that want access to the reclustered jets. It is highly configurable. In your runner macro, add the header\r\n\r\n```c++\r\n#include <JetReclustering/JetReclusteringAlgo.h>\r\n```\r\n\r\nand then simply set up your algorithm like so\r\n\r\n```c++\r\n// initialize and set it up\r\nJetReclustering* jetReclusterer = new JetReclusteringAlgo();\r\njetReclusterer->m_inputJetContainer = \"AntiKt4LCTopoJets\";\r\njetReclusterer->m_outputJetContainer = \"AntiKt10LCTopoJetsRCAntiKt4LCTopoJets\";\r\njetReclusterer->m_name = \"R10\"; // unique name for the tool\r\njetReclusterer->m_ptMin_input = 25.0; // GeV\r\njetReclusterer->m_ptMin_rc = 50.0; // GeV\r\njetReclusterer->m_ptFrac = 0.05; // GeV\r\n\r\n// ...\r\n// ...\r\n// ...\r\n\r\n// add it to your job sometime later\r\njob.algsAdd(jetReclusterer);\r\n```\r\n\r\n#### Athena\r\n\r\nAs with RootCore this is the best way to use the tool (Athena is designed to execute a series of algorithms after all...).\r\nAll you need to do is create a `JetReclusteringTool` in the `ToolSvc`, add an `AthJetReclusteringAlgo` to your `AlgSequence` and connect them\r\n\r\n```python\r\nToolSvc += CfgMgr.JetReclusteringTool(\"MyJetReclusteringTool\", InputJetContainer = \"AntiKt4EMTopoJets\", OutputJetContainer = \"AntiKt10EMTopoJets_RC\") # Set up properties here\r\nToolSvc.MyJetReclusteringTool.InputJetPtMin = 10 #Can also set properties like this\r\n\r\nalgseq = CfgMgr.AthSequencer(\"AthAlgSeq\")                #gets the main AthSequencer\r\nalgseq += CfgMgr.AthJetReclusteringAlgo(\"JetRecAlgo\", JetReclusteringTool = ToolSvc.MyJetReclusteringTool)\r\n```\r\n\r\nNow any algorithm downstream of this in algseq will have access to the `AntiKt10EMPTopoJets_RC` container.\r\nAn example (and a test you can use) is in `share/AthJetReclusteringAlgoJobOptions.py`\r\n\r\n## Studies and Example Usage\r\n\r\nSee [kratsg/ReclusteringStudies](https://github.com/kratsg/ReclusteringStudies) for studies and example usage.\r\n\r\n### Accessing the subjets from constituents\r\n\r\nThe reclustered jets have constituents which are your input small-R jets. These can be re-inflated, so to speak. As an example, I wanted to get the btagging information of my subjets as well as their constituents (eg: the topological calorimeter clusters, `TopoCaloClusters`)\r\n\r\n```c++\r\nfor(auto jet: *in_jets){\r\n  const xAOD::Jet* subjet(nullptr);\r\n  const xAOD::BTagging* btag(nullptr);\r\n  for(auto constit: jet->getConstituents()){\r\n    if (subjet->type() != xAOD::Type::Jet) {\r\n      // You need to handle this somehow\r\n      continue;\r\n    }\r\n    subjet = static_cast<const xAOD::Jet*>(constit->rawConstituent());\r\n    btag = subjet->btagging();\r\n    if(btag)\r\n      Info(\"execute()\", \"btagging: %0.2f\", btag->MV1_discriminant());\r\n\r\n    for(auto subjet_constit: subjet->getConstituents())\r\n      Info(\"execute()\", \"\\tconstituent pt: %0.2f\", subjet_constit->pt());\r\n  }\r\n}\r\n```\r\n\r\nwhere we explicitly `static_cast<>` our raw pointer from the `rawConstituent()` call. See [xAODJet/JetConstituentVector.h](http://acode-browser.usatlas.bnl.gov/lxr/source/atlas/Event/xAOD/xAODJet/xAODJet/JetConstituentVector.h) for more information about what is available. As a raw pointer, we already know that the input to the constituents were small-R jets (since we re-clustered ourselves) so this type of casting is safe.\r\n\r\n### Accessing various jet moments\r\n\r\nWe try to use the standard `JetModifier` tools that are available ATLAS-wide. In those cases, you can find a lot more information on the [Run 2 - Jet Moments](https://twiki.cern.ch/twiki/bin/viewauth/AtlasProtected/Run2JetMoments) twiki. There are two ways to figure out what information is stored on the reclustered jet.\r\n\r\n1. Store the reclustered jets in an output xAOD. Use [kratsg/xAODDumper](https://github.com/kratsg/xAODDumper) to dump the properties and attributes of the jet containers associated with the reclustered jets.\r\n2. Go to [Root/JetReclusteringTool.cxx](Root/JetReclusteringTool.cxx#L101) around line 100, find the `modArray.push_back()` calls, and look at all the tools being added. For a given tool, you can look it up in the [Run 2 - Jet Moments](https://twiki.cern.ch/twiki/bin/viewauth/AtlasProtected/Run2JetMoments) twiki to figure out the corresponding property names.\r\n\r\nAs an example of the second way, I see that `m_ktSplittingScaleTool` is added. On the twiki, I see an entry for `KTSplittingScaleTool` which lists 6 variables associated with it: `Split12, Split23, Split34, ZCut12, ZCut23, ZCut34` and all are of a `float` type, so I can write\r\n\r\n```c++\r\nstatic SG::AuxElement::ConstAccessor<float> Split12(\"Split12\");\r\nstatic SG::AuxElement::ConstAccessor<float> Split23(\"Split23\");\r\nstatic SG::AuxElement::ConstAccessor<float> Split34(\"Split34\");\r\nstatic SG::AuxElement::ConstAccessor<float> ZCut12(\"ZCut12\");\r\nstatic SG::AuxElement::ConstAccessor<float> ZCut23(\"ZCut23\");\r\nstatic SG::AuxElement::ConstAccessor<float> ZCut34(\"ZCut34\");\r\n```\r\n\r\nand with these, I can quickly access it on my jet (protecting myself against when it doesn't exist for some reason)\r\n\r\n```c++\r\nfor(auto jet: *in_jets){\r\n  if(Split12.isAvailable(*jet))\r\n    Info(\"execute()\", \"\\tSplit12: %0.2f\", Split12(*jet));\r\n  if(Split23.isAvailable(*jet))\r\n    Info(\"execute()\", \"\\tSplit23: %0.2f\", Split23(*jet));\r\n  if(Split34.isAvailable(*jet))\r\n    Info(\"execute()\", \"\\tSplit34: %0.2f\", Split34(*jet));\r\n  if(ZCut12.isAvailable(*jet))\r\n    Info(\"execute()\", \"\\tZCut12: %0.2f\", ZCut12(*jet));\r\n  if(ZCut23.isAvailable(*jet))\r\n    Info(\"execute()\", \"\\tZCut23: %0.2f\", ZCut23(*jet));\r\n  if(ZCut34.isAvailable(*jet))\r\n    Info(\"execute()\", \"\\tZCut34: %0.2f\", ZCut34(*jet));\r\n}\r\n\r\n```\r\n\r\n## Authors\r\n- [Giordon Stark](https://github.com/kratsg)\r\n- [Jon Burr](https://github.com/j0nburr)\r\n",
  "google": "UA-56943050-2",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}